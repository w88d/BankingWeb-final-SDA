'use strict';

const postcss = require('postcss');
const selectorParser = require('postcss-selector-parser');
const valueParser = require('postcss-value-parser');
const { extractICSS } = require('icss-utils');

const isSpacing = node => node.type === 'combinator' && node.value === ' ';

function getImportLocalAliases(icssImports) {
  const localAliases = new Map();
  Object.keys(icssImports).forEach(key => {
    Object.keys(icssImports[key]).forEach(prop => {
      localAliases.set(prop, icssImports[key][prop]);
    });
  });
  return localAliases;
}

function maybeLocalizeValue(value, localAliasMap) {
  if (localAliasMap.has(value)) return value;
}

function normalizeNodeArray(nodes) {
  const array = [];

  nodes.forEach(function(x) {
    if (Array.isArray(x)) {
      normalizeNodeArray(x).forEach(function(item) {
        array.push(item);
      });
    } else if (x) {
      array.push(x);
    }
  });

  if (array.length > 0 && isSpacing(array[array.length - 1])) {
    array.pop();
  }
  return array;
}

function localizeNode(rule, mode, localAliasMap) {
  const isScopePseudo = node =>
    node.value === ':local' || node.value === ':global';
  const isImportExportPseudo = node =>
    node.value === ':import' || node.value === ':export';

  const transform = (node, context) => {
    if (context.ignoreNextSpacing && !isSpacing(node)) {
      throw new Error('Missing whitespace after ' + context.ignoreNextSpacing);
    }
    if (context.enforceNoSpacing && isSpacing(node)) {
      throw new Error('Missing whitespace before ' + context.enforceNoSpacing);
    }

    let newNodes;
    switch (node.type) {
      case 'root': {
        let resultingGlobal;

        context.hasPureGlobals = false;

        newNodes = node.nodes.map(function(n) {
          const nContext = {
            global: context.global,
            lastWasSpacing: true,
            hasLocals: false,
            explicit: false,
          };

          n = transform(n, nContext);

          if (typeof resultingGlobal === 'undefined') {
            resultingGlobal = nContext.global;
          } else if (resultingGlobal !== nContext.global) {
            throw new Error(
              'Inconsistent rule global/local result in rule "' +
                node +
                '" (multiple selectors must result in the same mode for the rule)'
            );
          }

          if (!nContext.hasLocals) {
            context.hasPureGlobals = true;
          }

          return n;
        });

        context.global = resultingGlobal;

        node.nodes = normalizeNodeArray(newNodes);
        break;
      }
      case 'selector': {
        newNodes = node.map(childNode => transform(childNode, context));

        node = node.clone();
        node.nodes = normalizeNodeArray(newNodes);
        break;
      }
      case 'combinator': {
        if (isSpacing(node)) {
          if (context.ignoreNextSpacing) {
            context.ignoreNextSpacing = false;
            context.lastWasSpacing = false;
            context.enforceNoSpacing = false;
            return null;
          }
          context.lastWasSpacing = true;
          return node;
        }
        break;
      }
      case 'pseudo': {
        let childContext;
        const isNested = !!node.length;
        const isScoped = isScopePseudo(node);
        const isImportExport = isImportExportPseudo(node);

        if (isImportExport) {
          context.hasLocals = true;
        // :local(.foo)
        } else if (isNested) {
          if (isScoped) {
            if (node.nodes.length === 0) {
              throw new Error(`${node.value}() can't be empty`);
            }

            if (context.inside) {
              throw new Error(
                `A ${node.value} is not allowed inside of a ${
                  context.inside
                }(...)`
              );
            }

            childContext = {
              global: node.value === ':global',
              inside: node.value,
              hasLocals: false,
              explicit: true,
            };

            newNodes = node
              .map(childNode => transform(childNode, childContext))
              .reduce((acc, next) => acc.concat(next.nodes), []);

            if (newNodes.length) {
              const { before, after } = node.spaces;

              const first = newNodes[0];
              const last = newNodes[newNodes.length - 1];

              first.spaces = { before, after: first.spaces.after };
              last.spaces = { before: last.spaces.before, after };
            }

            node = newNodes;

            break;
          } else {
            childContext = {
              global: context.global,
              inside: context.inside,
              lastWasSpacing: true,
              hasLocals: false,
              explicit: context.explicit,
            };
            newNodes = node.map(childNode =>
              transform(childNode, childContext)
            );

            node = node.clone();
            node.nodes = normalizeNodeArray(newNodes);

            if (childContext.hasLocals) {
              context.hasLocals = true;
            }
          }
          break;

          //:local .foo .bar
        } else if (isScoped) {
          if (context.inside) {
            